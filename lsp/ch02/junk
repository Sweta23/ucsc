Brad Selbrede
Linux System Programming
Chapter 2

File and File IO

Assignment Questions


2.1 Write a simple program to count the number of chars, words and lines in an
    ASCII text file – as a simple implementation of the wc utility.

2.2 Write a simple program 
  a) to read the contents of one or more ASCII text file(s), and print it out.
     as a simple implementation of the cat utility.

  b) modify a above to take the -l argument, that prints out each line prefixed
     by line# in the file.

2.3 Determine the limit of maximum number of open files, using sysconf().

2.4 Write a simple program to redirect both -- stdin and stdout, to files 
  a) stdin to read from a file, 

  b) stdout “echoes” stdin, and,

  c) stderr to display #lines copied.

2.5 Write a simple program that is a simple version of the ls utility. 
  a) list the names of all files in the current working directory.

Extra Credit
  b) Modify 2.5 to take a command line argument. If the argument is a filename
  list only the filename. If the argument is a directory name, list the
  directory name followed by the contents of the directory.

  c) Modify tthe program in 2.5b to accapt command line options. add support
     for the -l, long listing, option flag. 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// a program that copies the contents of files to stdout. 
// a simplified version of the cat utility.
// uses fgets() and kinda assumes that the file is plain 
// text. 


int main(int argc, char** argv)
{
    FILE* file;
    int show_line_nr = 0;
    int line_nr;
    char* buf = 0;
    int bufsize = 256;

    int i, j;
    char* arg; // make convenient notation.

    buf = malloc(bufsize);

    for (i=1; i<argc; ++i) {
        arg = argv[i];
        
        if ('-' == arg[0]) {
            // this is a cmd line option

            // iterate over individual chars to accum options
            for (j=1; j<strlen(arg); ++j) {
                 switch (arg[j]) {
                    case 'l':
                        show_line_nr = 1;
                        break;
                    default:
                        break;
                 } // switch
            } // for each option letter

        } else {
            // assume that arg is a filename.

            // open the file and copy it line by line to stdout.
            if (0 != (file = fopen(arg, "r"))) {
                line_nr = 0;
                while (fgets(buf, bufsize, file)) {
                    ++line_nr;
                    if (show_line_nr) {
                        printf("%8d  %s", line_nr, buf);
                    } else {
                        printf("%s", buf);
                    }
                }
                close(file);
            }
        } // else its a filename 

    } // for each arg in the cmd line arg list

    if (buf) free(buf);
    return 0;
}
#include <stdio.h>
#include <stdlib.h> // malloc(), free()
#include <unistd.h> // open(), read(), and close()
#include <fcntl.h> // O_RDONLY flag
#include <ctype.h> // isalnum()

/* word_couunt.c
 * a simple program to count the characters, words and lines in a text file. 
 * this is meant to be a simplified approximation of the 'wc' system utility.
 *
 * usage: 
 *   word_count <path>
 *
 * intent: 
 *   open the file named on the command line and read a chunk of data from it.
 *   for each chunk, 
 *     iterate over each character
 *     classify each character and keep count of each type of character.
 *     use a simple state machine to facilitate word counts.
 *     any sequence of non-whitespace characters is counted as a word.
 */




int main(int argc, char** argv)
{
    int fd = -1;
    int bufsize = 4096;
    int length; // how many bytes read?
    char* buf = 0;
    char* filename;

    // accumulators
    int char_count = 0;
    int word_count = 0;
    int line_count = 0;

    // state
    enum {INITIAL, WORD, SPACE} state;

    if (argc < 2) {
        fprintf(stderr, "usage: %s <filename>\n", argv[0]);
        goto out;
    }

    filename = argv[1]; // convenience
    fd = open(filename, O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "failed to open file\n");
        goto out;
    }

    buf = malloc(bufsize);
    if (0 == buf) {
        fprintf(stderr, "failed to allocate a read buffer.\n");
        goto out;
    }


    state = INITIAL;
    while (0 < (length = read(fd, buf, bufsize))) {
        int i;
        char c;
        
        char_count += length;

        for (i=0; i<length; ++i) {
            c = buf[i]; // convenience.
            
            // count lines
            if ('\n' == c) {
                ++line_count;
            }

            // count words
            switch (state) {

            case INITIAL:
                if (!isspace(c)) {
                    ++word_count;
                    state = WORD;
                } else {
                    state = SPACE;
                }
                break;

            case WORD:
                if (isspace(c)) {
                    state = SPACE;
                }
                break;

            case SPACE:
                if (!isspace(c)) {
                    ++word_count;
                    state = WORD;
                }
                break;

            default:
                // should never get here. 
                fprintf(stderr, "Somebody has disturbed the space-time continuum\n");
                state = INITIAL;
                break;
            } // switch
        } // for each character
    } // while

    // print out the counts
    //printf("characters: %d, words: %d, lines: %d\n", char_count, word_count, line_count);
    // make it look like the output of wc
    printf("  %d %d %d %s\n", line_count, word_count, char_count, filename);

out:
    if (buf) {
        free(buf);
    }

    if (0 < fd) {
        close(fd);
    }

    return 0;
}
